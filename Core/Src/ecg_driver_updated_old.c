/*
 * ECG_Driver.c (Updated for proper AI buffer configuration and alignment)
 *
 *  Created on: Jul 29, 2025
 *      Author: Yathi
 */
/* ecg_driver_updated.c - ECG signal acquisition, preprocessing, and AI inference task */

#include "main.h"
#include "FreeRTOS.h"
#include "ai_datatypes_defines.h"
#include "ecgai_network.h"
#include "ecgai_network_data.h"
#include <stdio.h>
#include <string.h>
#include <math.h>
#include "task.h"
#include "queue.h"
#include "semphr.h"



#define MODEL_INPUT_SIZE     1000

#define AI_INPUT_SCALE       (0.0289939995855093f)
#define AI_INPUT_ZERO_POINT  (114)
#define AI_OUTPUT_SCALE      (0.00390625f)
#define AI_OUTPUT_ZERO_POINT (0)

#define __CLAMP(x, min, max)  ((x) < (min) ? (min) : ((x) > (max) ? (max) : (x)))

static ai_handle ecg_network = AI_HANDLE_NULL;

static ai_i8 ai_input_buffer[AI_ECGAI_NETWORK_IN_1_SIZE_BYTES];
static ai_i8 ai_output_buffer[AI_ECGAI_NETWORK_OUT_1_SIZE_BYTES];

AI_ALIGNED(4)
static ai_u8 ai_activations[AI_ECGAI_NETWORK_DATA_ACTIVATIONS_SIZE];

/* ai_buffer definitions */
static ai_buffer ai_input[AI_ECGAI_NETWORK_IN_NUM] = {
    AI_BUFFER_OBJ_INIT(
        AI_BUFFER_FORMAT_Q7,                 /* Data format */
        1, MODEL_INPUT_SIZE, 1, 1,          /* Batches, Width, Height, Channels */
        AI_HANDLE_PTR(ai_input_buffer)      /* Data pointer */
    )
};

static ai_buffer ai_output[AI_ECGAI_NETWORK_OUT_NUM] = {
    AI_BUFFER_OBJ_INIT(
        AI_BUFFER_FORMAT_Q7,
        1, AI_ECGAI_NETWORK_OUT_1_SIZE, 1, 1,
        AI_HANDLE_PTR(ai_output_buffer)
    )
};


extern UART_HandleTypeDef huart3;
extern ADC_HandleTypeDef hadc1;

/* Extern handles auto-generated by X-CUBE-AI */
extern ai_handle g_ecgai_network_weights_table[];
extern ai_handle g_ecgai_network_activations_table[];

///* Initialize AI network */
//static void InitAI(void)
//{
//    ai_error err;
//    /* Build handle arrays */
//
//    err = ai_ecgai_network_create_and_init(
//                &ecg_network,
//				g_ecgai_network_activations_table,
//				g_ecgai_network_weights_table
//	);
//    if (err.type != AI_ERROR_NONE) {
//        char buf[64];
//        snprintf(buf, sizeof(buf), "AI Init error: %d\r\n", err.code);
//        HAL_UART_Transmit(&huart3, (uint8_t*)buf, strlen(buf), HAL_MAX_DELAY);
//        ecg_network = AI_HANDLE_NULL;
////        return;
//    }
//    /* Retrieve I/O buffer handles and override data pointers */
////       ai_buffer* ai_inputs  = ai_ecgai_network_inputs_get(ecg_network, NULL);
////       ai_buffer* ai_outputs = ai_ecgai_network_outputs_get(ecg_network, NULL);
////       ai_inputs[0].data   = AI_HANDLE_PTR(ai_input_buffer);
////       ai_outputs[0].data  = AI_HANDLE_PTR(ai_output_buffer);
//}

static inline int16_t ReadADC(void)
{
    HAL_ADC_Start(&hadc1);
    HAL_ADC_PollForConversion(&hadc1, HAL_MAX_DELAY);
    return HAL_ADC_GetValue(&hadc1);
}

/* Initialize AI network */
static void InitAI(void)
{
    ai_error err = ai_ecgai_network_create_and_init(
        &ecg_network,
        g_ecgai_network_activations_table,
        g_ecgai_network_weights_table
    );

    if (err.type != AI_ERROR_NONE) {
        char buf[64];
        snprintf(buf, sizeof(buf), "AI Init error: %d\r\n", err.code);
        HAL_UART_Transmit(&huart3, (uint8_t*)buf, strlen(buf), HAL_MAX_DELAY);
        ecg_network = AI_HANDLE_NULL;
    }
}


/* Main ECG sampling & inference task */
void ECGSamplingTask(void *argument)
{
    InitAI();
    int sample_idx = 0;
    TickType_t last_wake = xTaskGetTickCount();

    while (1) {
        vTaskDelayUntil(&last_wake, pdMS_TO_TICKS(1));

        /* Acquire and preprocess sample */
        float voltage = ReadADC() * (3.3f / 4095.0f);
        /* Example high-pass: remove mean (1.5V) */
        float filtered = voltage - 1.5f;
        /* Quantize */
        int32_t q = (int32_t)roundf(filtered / AI_INPUT_SCALE) + AI_INPUT_ZERO_POINT;
        ai_input_buffer[sample_idx++] = (int8_t)__CLAMP(q, -128, 127);

        /* Once buffer full, run inference */
        if (sample_idx >= MODEL_INPUT_SIZE) {
            sample_idx = 0;
            if (ecg_network == AI_HANDLE_NULL) continue;
            ai_i32 ret = ai_ecgai_network_run(ecg_network, ai_input, ai_output);
            if (ret != 1) {
//            if (ecg_network != AI_HANDLE_NULL) {
//                if (ai_ecgai_network_run(ecg_network, ai_input, ai_output) != 1) {
                	const char* msg = "AI run failed\r\n";
                	HAL_UART_Transmit(&huart3, (uint8_t*)msg, strlen(msg), HAL_MAX_DELAY);
                } else {
                    int8_t yq = ai_output_buffer[0];
                    float score = (yq - AI_OUTPUT_ZERO_POINT) * AI_OUTPUT_SCALE;
                    char out[64];
                    snprintf(out, sizeof(out), "Anomaly score: %.2f\r\n", score);
                    HAL_UART_Transmit(&huart3, (uint8_t*)out, strlen(out), HAL_MAX_DELAY);
                }
            }
        }
}

void vApplicationStackOverflowHook(TaskHandle_t xTask, char *pcTaskName)
{
    char buf[128];
    snprintf(buf,sizeof(buf),"Stack overflow in %s\r\n",pcTaskName);
    HAL_UART_Transmit(&huart3,(uint8_t*)buf,strlen(buf),HAL_MAX_DELAY);
    taskDISABLE_INTERRUPTS();
    while(1);
}
