/*
 * ecg_driver_updated.c - ECG signal acquisition, preprocessing, and AI inference task
 * Updated for X-CUBE-AI 10.1.0 with corrected ai_ecgai_network_run call
 *
 * Created on: Jul 29, 2025
 * Author: Yathi
 */
//
//#include "main.h"
//#include "FreeRTOS.h"
//#include "ai_datatypes_defines.h"
//#include "ecgai_network.h"
//#include "ecgai_network_data.h"
//#include <stdio.h>
//#include <string.h>
//#include <math.h>
//#include "task.h"
//#include "queue.h"
//#include "semphr.h"
//
//#define MODEL_INPUT_SIZE     1000
//#define AI_INPUT_SCALE       (0.028994000f)
//#define AI_INPUT_ZERO_POINT  (114)
//#define AI_OUTPUT_SCALE      (0.00390625f)
//#define AI_OUTPUT_ZERO_POINT (0)
//
//#define __CLAMP(x, min, max)  ((x) < (min) ? (min) : ((x) > (max) ? (max) : (x)))
//
///* ADC and UART handles */
//extern ADC_HandleTypeDef hadc1;
//extern UART_HandleTypeDef huart3;
//
///* Semaphores */
//SemaphoreHandle_t adcSemaphore;
//SemaphoreHandle_t uartSemaphore;
//
///* Buffer for ECG data */
//#define ECG_BUFFER_SIZE 256
//static float ecgFilteredBuffer[ECG_BUFFER_SIZE];
//static float modelInputBuffer[MODEL_INPUT_SIZE];
//static uint32_t bufferIndex = 0;
//static uint32_t sampleCount = 0;
//
//static float dynamicMean = 0.0f;
//
///* Filter coefficients */
//static const float notchFilterB[] = {1.0f, -1.4142f, 1.0f};
//static const float notchFilterA[] = {1.0f, -1.8478f, 0.9114f};
//static const float highPassB[] = {1.0f, -1.0f};
//static const float highPassA[] = {1.0f, -0.995f};
//static float notchState[2] = {0.0f, 0.0f};
//static float hpState[1] = {0.0f};
//
///* AI network and buffers */
//static ai_handle ecg_network = AI_HANDLE_NULL;
//static ai_i8 ai_input_buffer[AI_ECGAI_NETWORK_IN_1_SIZE_BYTES];
//static ai_i8 ai_output_buffer[AI_ECGAI_NETWORK_OUT_1_SIZE_BYTES];
//
//AI_ALIGNED(4)
//static ai_u8 ai_activations[AI_ECGAI_NETWORK_DATA_ACTIVATIONS_SIZE];
//
///* ai_buffer definitions */
//static ai_buffer ai_input[AI_ECGAI_NETWORK_IN_NUM] = {
//    AI_BUFFER_OBJ_INIT(
//        AI_BUFFER_FORMAT_Q7,                 /* Data format */
//        1, MODEL_INPUT_SIZE, 1, 1,          /* Batches, Width, Height, Channels */
//        AI_HANDLE_PTR(ai_input_buffer)      /* Data pointer */
//    )
//};
//
//static ai_buffer ai_output[AI_ECGAI_NETWORK_OUT_NUM] = {
//    AI_BUFFER_OBJ_INIT(
//        AI_BUFFER_FORMAT_Q7,
//        1, AI_ECGAI_NETWORK_OUT_1_SIZE, 1, 1,
//        AI_HANDLE_PTR(ai_output_buffer)
//    )
//};
//
///* Extern handles auto-generated by X-CUBE-AI */
//extern ai_handle g_ecgai_network_weights_table[];
//extern ai_handle g_ecgai_network_activations_table[];
//
///* Apply IIR filter (Direct Form I) */
//static float applyIIRFilter(float input, const float *b, const float *a, float *state, uint32_t order) {
//    float output = b[0] * input + state[0];
//    for (uint32_t i = 1; i <= order; i++) {
//        state[i - 1] = b[i] * input - a[i] * output + (i < order ? state[i] : 0);
//    }
//    return __CLAMP(output, -3.3f, 3.3f);
//}
//
///* Compute dynamic mean */
//static float computeMean(float *buffer, uint32_t size) {
//    float sum = 0.0f;
//    for (uint32_t i = 0; i < size; i++) sum += buffer[i];
//    return sum / size;
//}
//
//
///* Initialize AI network */
//static void InitAI(void) {
//    ai_error err = ai_ecgai_network_create_and_init(
//        &ecg_network,
//        g_ecgai_network_activations_table,
//        g_ecgai_network_weights_table
//    );
//
//    if (err.type != AI_ERROR_NONE) {
//        char buf[64];
//        snprintf(buf, sizeof(buf), "AI Init error: type=%d, code=%d\r\n", err.type, err.code);
//        if (xSemaphoreTake(uartSemaphore, pdMS_TO_TICKS(10)) == pdTRUE) {
//            HAL_UART_Transmit(&huart3, (uint8_t*)buf, strlen(buf), HAL_MAX_DELAY);
//            xSemaphoreGive(uartSemaphore);
//        }
//        ecg_network = AI_HANDLE_NULL;
////        Error_Handler();
//    }
//}
//
///* Read ADC value */
//static inline int16_t ReadADC(void) {
//    if (xSemaphoreTake(adcSemaphore, pdMS_TO_TICKS(10)) == pdTRUE) {
//        HAL_ADC_Start(&hadc1);
//        if (HAL_ADC_PollForConversion(&hadc1, 10) == HAL_OK) {
//            int16_t value = HAL_ADC_GetValue(&hadc1);
//            HAL_ADC_Stop(&hadc1);
//            xSemaphoreGive(adcSemaphore);
//            return value;
//        }
//        HAL_ADC_Stop(&hadc1);
//        xSemaphoreGive(adcSemaphore);
//    }
//    return 2048; // Return mid-scale if ADC read fails
//}
//
///* Main ECG sampling & inference task */
//void ECGSamplingTask(void *argument) {
//    InitAI();
//    int sample_idx = 0;
//    TickType_t last_wake = xTaskGetTickCount();
//    char uartBuffer[128];
//
//    while (1) {
//        vTaskDelayUntil(&last_wake, pdMS_TO_TICKS(1));
//
//        /* Acquire and preprocess sample */
//        float voltage = ReadADC() * (3.3f / 4095.0f);
//        float filtered = applyIIRFilter(voltage, notchFilterB, notchFilterA, notchState, 2);
//        filtered = applyIIRFilter(filtered, highPassB, highPassA, hpState, 1);
//        ecgFilteredBuffer[bufferIndex] = filtered; // Store for logging
//        modelInputBuffer[sampleCount++] = filtered;
//
//        /* Compute dynamic mean */
//                if (sampleCount == MODEL_INPUT_SIZE) {
//                    dynamicMean = computeMean(modelInputBuffer, MODEL_INPUT_SIZE);
//                }
//
//
//        /* Quantize */
//        int32_t q = (int32_t)roundf((filtered - dynamicMean) / AI_INPUT_SCALE) + AI_INPUT_ZERO_POINT;
//        ai_input_buffer[sample_idx++] = (ai_i8)__CLAMP(q, 0, 255); // uint8 range
//
//        /* Debug: Log raw and filtered values every 100 samples */
//        if (sample_idx % 100 == 0 && sample_idx > 0) {
////            snprintf(uartBuffer, sizeof(uartBuffer), "Raw:%d,Filtered:%.4f,Quant:%d\r\n", ReadADC(), filtered, (int_t)ai_input_buffer[sample_idx-1]);
//        	snprintf(uartBuffer, sizeof(uartBuffer), "Raw:%d,Filtered:%.4f,Quant:%u,Mean:%.4f\r\n",
//        	                     ReadADC(), filtered, (uint8_t)ai_input_buffer[sample_idx-1], dynamicMean);
//
//            if (xSemaphoreTake(uartSemaphore, pdMS_TO_TICKS(10)) == pdTRUE) {
//                HAL_UART_Transmit(&huart3, (uint8_t*)uartBuffer, strlen(uartBuffer), HAL_MAX_DELAY);
//                xSemaphoreGive(uartSemaphore);
//            }
//        }
//
//        /* Run inference every 1000 samples */
//        if (sample_idx >= MODEL_INPUT_SIZE) {
//
//        	/* Reset filter states to prevent instability */
//        	            notchState[0] = notchState[1] = 0.0f;
//        	            hpState[0] = 0.0f;
//
//            /* Log input statistics */
//            float mean = 0.0f, std = 0.0f, min = 255.0f, max = 0.0f;
//            for (int i = 0; i < MODEL_INPUT_SIZE; i++) {
//                float dequant = ((float)ai_input_buffer[i] - AI_INPUT_ZERO_POINT) * AI_INPUT_SCALE;
//                mean += dequant;
//                if (ai_input_buffer[i] < min) min = ai_input_buffer[i];
//                if (ai_input_buffer[i] > max) max = ai_input_buffer[i];
//            }
//            mean /= MODEL_INPUT_SIZE;
//            for (int i = 0; i < MODEL_INPUT_SIZE; i++) {
//                float dequant = ((float)ai_input_buffer[i] - AI_INPUT_ZERO_POINT) * AI_INPUT_SCALE;
//                std += (dequant - mean) * (dequant - mean);
//            }
//            std = sqrtf(std / MODEL_INPUT_SIZE);
//            snprintf(uartBuffer, sizeof(uartBuffer), "Input stats: min=%u, max=%u, mean=%.4f, std=%.4f\r\n", (uint8_t)min, (uint8_t)max, mean, std);
//            if (xSemaphoreTake(uartSemaphore, pdMS_TO_TICKS(10)) == pdTRUE) {
//                HAL_UART_Transmit(&huart3, (uint8_t*)uartBuffer, strlen(uartBuffer), HAL_MAX_DELAY);
//                xSemaphoreGive(uartSemaphore);
//            }
//
//            sample_idx = 0;
//            if (ecg_network == AI_HANDLE_NULL) {
//                snprintf(uartBuffer, sizeof(uartBuffer), "AI network not initialized\r\n");
//                if (xSemaphoreTake(uartSemaphore, pdMS_TO_TICKS(10)) == pdTRUE) {
//                    HAL_UART_Transmit(&huart3, (uint8_t*)uartBuffer, strlen(uartBuffer), HAL_MAX_DELAY);
//                    xSemaphoreGive(uartSemaphore);
//                }
//                continue;
//            }
//
//            /* Run inference */
//            ai_i32 ret = ai_ecgai_network_run(ecg_network, ai_input, ai_output);
//            if (ret <= 0) {
//            	ai_error err = ai_ecgai_network_get_error(ecg_network);
//            	                snprintf(uartBuffer, sizeof(uartBuffer), "AI run failed: ret=%d, type=%d, code=%d\r\n", ret, err.type, err.code);
//                if (xSemaphoreTake(uartSemaphore, pdMS_TO_TICKS(10)) == pdTRUE) {
//                    HAL_UART_Transmit(&huart3, (uint8_t*)uartBuffer, strlen(uartBuffer), HAL_MAX_DELAY);
//                    xSemaphoreGive(uartSemaphore);
//                }
//            } else {
//                ai_i8 yq = ai_output_buffer[0];
//                float score = ((float)yq - AI_OUTPUT_ZERO_POINT) * AI_OUTPUT_SCALE;
//                int is_anomaly = score > 0.5f ? 1 : 0;
//                snprintf(uartBuffer, sizeof(uartBuffer), "Anomaly:%d,Score:%.2f\r\n", is_anomaly, score);
//                if (xSemaphoreTake(uartSemaphore, pdMS_TO_TICKS(10)) == pdTRUE) {
//                    HAL_UART_Transmit(&huart3, (uint8_t*)uartBuffer, strlen(uartBuffer), HAL_MAX_DELAY);
//                    xSemaphoreGive(uartSemaphore);
//                }
//            }
//            sampleCount = 0; // Reset buffer
//        }
//
//        /* Update circular buffer */
//        bufferIndex = (bufferIndex + 1) % ECG_BUFFER_SIZE;
//    }
//}

#include "main.h"
#include "FreeRTOS.h"
#include "ai_datatypes_defines.h"
#include "ecgai_network.h"
#include "ecgai_network_data.h"
#include <stdio.h>
#include <string.h>
#include <math.h>
#include "task.h"
#include "queue.h"
#include "semphr.h"

#define MODEL_INPUT_SIZE     1000
#define AI_INPUT_SCALE       (0.028994000f)
#define AI_INPUT_ZERO_POINT  (114)
#define AI_OUTPUT_SCALE      (0.00390625f)
#define AI_OUTPUT_ZERO_POINT (0)
//#define ECG_SCALE             (0.01f) // Adjust to match expected ECG amplitude

#define __CLAMP(x, min, max)  ((x) < (min) ? (min) : ((x) > (max) ? (max) : (x)))

/* ADC and UART handles */
extern ADC_HandleTypeDef hadc1;
extern UART_HandleTypeDef huart3;

/* Semaphores */
SemaphoreHandle_t adcSemaphore;
SemaphoreHandle_t uartSemaphore;

/* Buffer for ECG data */
//#define ECG_BUFFER_SIZE 256
//static float ecgFilteredBuffer[ECG_BUFFER_SIZE];
static float modelInputBuffer[MODEL_INPUT_SIZE];
//static uint32_t bufferIndex = 0;
static uint32_t sampleCount = 0;
static float dynamicMean = 0.0f;

/* Filter coefficients (1 kHz sampling, 50 Hz notch, 0.1 Hz high-pass) */
//static const float notchFilterB[] = {0.9530f, -1.6986f, 0.9530f};
//static const float notchFilterA[] = {1.0f, -1.6986f, 0.9060f};
//static const float highPassB[] = {0.9997f, -0.9997f};
//static const float highPassA[] = {1.0f, -0.9994f};
//static float notchState[2] = {0.0f, 0.0f};
//static float hpState[1] = {0.0f};

/* AI network and buffers */
static ai_handle ecg_network = AI_HANDLE_NULL;
static ai_u8 ai_input_buffer[AI_ECGAI_NETWORK_IN_1_SIZE_BYTES];
static ai_u8 ai_output_buffer[AI_ECGAI_NETWORK_OUT_1_SIZE_BYTES];

//AI_ALIGNED(4)
//static ai_u8 ai_activations[AI_ECGAI_NETWORK_DATA_ACTIVATIONS_SIZE];

/* ai_buffer definitions */
//static ai_buffer ai_input[AI_ECGAI_NETWORK_IN_NUM] = {
//    AI_BUFFER_OBJ_INIT(
//        AI_BUFFER_FORMAT_U8,
//        1, MODEL_INPUT_SIZE, 1, 1,
//        AI_HANDLE_PTR(ai_input_buffer)
//    )
//};
//
//static ai_buffer ai_output[AI_ECGAI_NETWORK_OUT_NUM] = {
//    AI_BUFFER_OBJ_INIT(
//        AI_BUFFER_FORMAT_U8,
//        1, AI_ECGAI_NETWORK_OUT_1_SIZE, 1, 1,
//        AI_HANDLE_PTR(ai_output_buffer)
//    )
//};

static ai_buffer ai_input[AI_ECGAI_NETWORK_IN_NUM] = {
    AI_BUFFER_INIT(
        AI_FLAG_NONE,
        AI_BUFFER_FORMAT_U8,
        AI_BUFFER_SHAPE_INIT(AI_SHAPE_BCWH, 4, 1, 1, MODEL_INPUT_SIZE, 1),
        MODEL_INPUT_SIZE,
        NULL,
        AI_HANDLE_PTR(ai_input_buffer)
    )
};

static ai_buffer ai_output[AI_ECGAI_NETWORK_OUT_NUM] = {
    AI_BUFFER_INIT(
        AI_FLAG_NONE,
        AI_BUFFER_FORMAT_U8,
        AI_BUFFER_SHAPE_INIT(AI_SHAPE_BCWH, 4, 1, 1, AI_ECGAI_NETWORK_OUT_1_SIZE, 1),
        AI_ECGAI_NETWORK_OUT_1_SIZE,
        NULL,
        AI_HANDLE_PTR(ai_output_buffer)
    )
};


/* Extern handles auto-generated by X-CUBE-AI */
extern ai_handle g_ecgai_network_weights_table[];
extern ai_handle g_ecgai_network_activations_table[];

/* Apply IIR filter (Direct Form I) */
//static float applyIIRFilter(float input, const float *b, const float *a, float *state, uint32_t order) {
//    float output = b[0] * input + state[0];
//    for (uint32_t i = 1; i <= order; i++) {
//        state[i - 1] = b[i] * input - a[i] * output + (i < order ? state[i] : 0);
//    }
//    return __CLAMP(output, -0.5f, 0.5f);
//}

/* Compute dynamic mean */
static float computeMean(float *buffer, uint32_t size) {
    float sum = 0.0f;
    for (uint32_t i = 0; i < size; i++) sum += buffer[i];
    return sum / size;
}

/* Initialize AI network */
static void InitAI(void) {
    ai_error err = ai_ecgai_network_create_and_init(
        &ecg_network,
        g_ecgai_network_activations_table,
        g_ecgai_network_weights_table
    );

    if (err.type != AI_ERROR_NONE) {
        char buf[64];
        snprintf(buf, sizeof(buf), "AI Init error: type=%d, code=%d\r\n", err.type, err.code);
        if (xSemaphoreTake(uartSemaphore, pdMS_TO_TICKS(10)) == pdTRUE) {
            HAL_UART_Transmit(&huart3, (uint8_t*)buf, strlen(buf), HAL_MAX_DELAY);
            xSemaphoreGive(uartSemaphore);
        }
        ecg_network = AI_HANDLE_NULL;
//        Error_Handler();
    }
}

/* Read ADC value */
static inline int16_t ReadADC(void) {
    if (xSemaphoreTake(adcSemaphore, pdMS_TO_TICKS(10)) == pdTRUE) {
        HAL_ADC_Start(&hadc1);
        if (HAL_ADC_PollForConversion(&hadc1, 10) == HAL_OK) {
            int16_t value = HAL_ADC_GetValue(&hadc1);
            HAL_ADC_Stop(&hadc1);
            xSemaphoreGive(adcSemaphore);
            return value;
        }
        HAL_ADC_Stop(&hadc1);
        xSemaphoreGive(adcSemaphore);
    }
    return 2048; // Return mid-scale if ADC read fails
}

/* HardFault Handler */
//void HardFault_Handler(void) {
//    __disable_irq();
//    char buf[128];
//    snprintf(buf, sizeof(buf), "HardFault: HFSR=0x%08lx, CFSR=0x%08lx, BFAR=0x%08lx\r\n",
//             SCB->HFSR, SCB->CFSR, SCB->BFAR);
//    if (xSemaphoreTakeFromISR(uartSemaphore, NULL) == pdTRUE) {
//        HAL_UART_Transmit(&huart3, (uint8_t*)buf, strlen(buf), HAL_MAX_DELAY);
//        xSemaphoreGiveFromISR(uartSemaphore, NULL);
//    }
//    while (1);
//}

/* Main ECG sampling & inference task */
void ECGSamplingTask(void *argument) {
    InitAI();
    int sample_idx = 0;
    TickType_t last_wake = xTaskGetTickCount();
    char uartBuffer[128];

    while (1) {
        vTaskDelayUntil(&last_wake, pdMS_TO_TICKS(1));

        /* Acquire and preprocess sample */
        float voltage = ReadADC() * (3.3f / 4095.0f);
        float filtered = voltage - 1.65f; // Center around 0V (Vref/2 = 1.65V)
//        float scaled = filtered * 10.0f; /* Scale to amplify signal */
//        float filtered = applyIIRFilter(voltage, notchFilterB, notchFilterA, notchState, 2);
//        filtered = applyIIRFilter(filtered, highPassB, highPassA, hpState, 1);
//        filtered = __CLAMP(filtered, -0.5f, 0.5f); // Apply gain and clamp
//        ecgFilteredBuffer[bufferIndex] = filtered;
        modelInputBuffer[sampleCount++] = filtered;
//
        /* Compute dynamic mean */
        if (sampleCount == MODEL_INPUT_SIZE) {
            dynamicMean = computeMean(modelInputBuffer, MODEL_INPUT_SIZE);
        }

        /* Quantize */
        int32_t q = (int32_t)roundf(filtered / AI_INPUT_SCALE) + AI_INPUT_ZERO_POINT;
        ai_input_buffer[sample_idx++] = (ai_u8)__CLAMP(q, 0, 255);

        /* Debug: Log raw and filtered values every 100 samples */
        if (sample_idx % 100 == 0 && sample_idx > 0) {
            snprintf(uartBuffer, sizeof(uartBuffer), "Raw:%d,Filtered:%.4f,Quant:%u,Mean:%.4f\r\n",
                     ReadADC(), filtered, (uint8_t)ai_input_buffer[sample_idx-1], dynamicMean);
            if (xSemaphoreTake(uartSemaphore, pdMS_TO_TICKS(10)) == pdTRUE) {
                HAL_UART_Transmit(&huart3, (uint8_t*)uartBuffer, strlen(uartBuffer), HAL_MAX_DELAY);
                xSemaphoreGive(uartSemaphore);
            }

            /* Reset filter states every 100 samples */
//            notchState[0] = notchState[1] = 0.0f;
//            hpState[0] = 0.0f;
        }

        /* Run inference every 1000 samples */
        if (sample_idx >= MODEL_INPUT_SIZE) {
            /* Reset filter states */
//            notchState[0] = notchState[1] = 0.0f;
//            hpState[0] = 0.0f;

            /* Log input statistics */
            float mean = 0.0f, std = 0.0f, min = 255.0f, max = 0.0f;
            for (int i = 0; i < MODEL_INPUT_SIZE; i++) {
                float dequant = ((float)ai_input_buffer[i] - AI_INPUT_ZERO_POINT) * AI_INPUT_SCALE;
                mean += dequant;
                if (ai_input_buffer[i] < min) min = ai_input_buffer[i];
                if (ai_input_buffer[i] > max) max = ai_input_buffer[i];
            }
            mean /= MODEL_INPUT_SIZE;
            for (int i = 0; i < MODEL_INPUT_SIZE; i++) {
                float dequant = ((float)ai_input_buffer[i] - AI_INPUT_ZERO_POINT) * AI_INPUT_SCALE;
                std += (dequant - mean) * (dequant - mean);
            }
            std = sqrtf(std / MODEL_INPUT_SIZE);
            snprintf(uartBuffer, sizeof(uartBuffer), "Input stats: min=%u, max=%u, mean=%.4f, std=%.4f\r\n",
                     (uint8_t)min, (uint8_t)max, mean, std);
            if (xSemaphoreTake(uartSemaphore, pdMS_TO_TICKS(10)) == pdTRUE) {
                HAL_UART_Transmit(&huart3, (uint8_t*)uartBuffer, strlen(uartBuffer), HAL_MAX_DELAY);
                xSemaphoreGive(uartSemaphore);
            }

            sample_idx = 0;
            if (ecg_network == AI_HANDLE_NULL) {
                snprintf(uartBuffer, sizeof(uartBuffer), "AI network not initialized\r\n");
                if (xSemaphoreTake(uartSemaphore, pdMS_TO_TICKS(10)) == pdTRUE) {
                    HAL_UART_Transmit(&huart3, (uint8_t*)uartBuffer, strlen(uartBuffer), HAL_MAX_DELAY);
                    xSemaphoreGive(uartSemaphore);
                }
                continue;
            }

            /* Run inference */
            ai_i32 ret = ai_ecgai_network_run(ecg_network, ai_input, ai_output);
            if (ret <= 0) {
                ai_error err = ai_ecgai_network_get_error(ecg_network);
                snprintf(uartBuffer, sizeof(uartBuffer), "AI run failed: ret=%ld, type=%d, code=%d\r\n",
                         ret, err.type, err.code);
                if (xSemaphoreTake(uartSemaphore, pdMS_TO_TICKS(10)) == pdTRUE) {
                    HAL_UART_Transmit(&huart3, (uint8_t*)uartBuffer, strlen(uartBuffer), HAL_MAX_DELAY);
                    xSemaphoreGive(uartSemaphore);
                }
            } else {
                ai_u8 yq = ai_output_buffer[0];
                float score = ((float)yq - AI_OUTPUT_ZERO_POINT) * AI_OUTPUT_SCALE;
                int is_anomaly = score > 0.5f ? 1 : 0;
                snprintf(uartBuffer, sizeof(uartBuffer), "Anomaly:%d,Score:%.2f\r\n", is_anomaly, score);
                if (xSemaphoreTake(uartSemaphore, pdMS_TO_TICKS(10)) == pdTRUE) {
                    HAL_UART_Transmit(&huart3, (uint8_t*)uartBuffer, strlen(uartBuffer), HAL_MAX_DELAY);
                    xSemaphoreGive(uartSemaphore);
                }
            }
            sampleCount = 0; // Reset buffer
        }

        /* Update circular buffer */
//        bufferIndex = (bufferIndex + 1) % ECG_BUFFER_SIZE;
    }
}


/* ECG Task and Semaphore Initialization */
void ECGTask_Init(void) {
    adcSemaphore = xSemaphoreCreateMutex();
    uartSemaphore = xSemaphoreCreateMutex();

}



/* Stack Overflow Hook */
void vApplicationStackOverflowHook(TaskHandle_t xTask, char *pcTaskName) {
    char buf[128];
    snprintf(buf, sizeof(buf), "Stack overflow in %s\r\n", pcTaskName);
    if (xSemaphoreTake(uartSemaphore, pdMS_TO_TICKS(10)) == pdTRUE) {
        HAL_UART_Transmit(&huart3, (uint8_t*)buf, strlen(buf), HAL_MAX_DELAY);
        xSemaphoreGive(uartSemaphore);
    }
    taskDISABLE_INTERRUPTS();
    while (1);
}
